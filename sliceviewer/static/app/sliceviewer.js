// Generated by CoffeeScript 1.9.3

/*
NOTE: this js file is generated by coffee, do not edit this file
 */

(function() {
  var ImageSquence, SliceViewerLayer, TileImages, exportObj, getImage, pixel2HU;

  exportObj = typeof exports !== "undefined" && exports !== null ? exports : this;

  exportObj.SliceViewer = (function() {
    function SliceViewer(args) {
      var canvas, i, len, name, ref, ref1, ref2, ref3, ref4, self, zindex;
      this.suid2urls = args.suid2urls;
      this.container = args.container;
      this.width = parseInt((ref = args.width) != null ? ref : 512);
      this.height = parseInt((ref1 = args.height) != null ? ref1 : 512);
      this.ui_prev = (args != null ? args.ui_prev : void 0) || null;
      this.ui_next = (args != null ? args.ui_next : void 0) || null;
      this.ui_index = (args != null ? args.ui_index : void 0) || null;
      this.ui_x_profile = (args != null ? args.ui_x_profile : void 0) || null;
      this.ui_y_profile = (args != null ? args.ui_y_profile : void 0) || null;
      this.name2canvas = {};
      this.name2layer = {};
      ref2 = ['ct'];
      for (zindex = i = 0, len = ref2.length; i < len; zindex = ++i) {
        name = ref2[zindex];
        canvas = this.name2canvas[name] = $(document.createElement('canvas'));
        canvas[0].width = this.width;
        canvas[0].height = this.height;
        canvas.css('z-index', zindex);
        canvas.css('position', 'absolute');
      }
      this.crosshair_canvas = $(document.createElement('canvas'));
      this.crosshair_canvas[0].width = this.width;
      this.crosshair_canvas[0].height = this.height;
      this.crosshair_canvas.css('z-index', 9999);
      this.crosshair_canvas.css('position', 'absolute');
      this.crosshair_x = (ref3 = args.crosshair_init_x) != null ? ref3 : this.width / 2;
      this.crosshair_y = (ref4 = args.crosshair_init_y) != null ? ref4 : this.height / 2;
      this.renderTo(this.container);
      self = this;
      $("#suid").change(function(e) {
        var cttype, div_spinner, opt, suid, tbody, url;
        url = $(e.target).val();
        opt = $(e.target).find('option:selected');
        suid = opt.data('suid');
        cttype = opt.data('type');
        tbody = $("#prediction tbody");
        tbody.html('');
        div_spinner = $("#prediction-spinner");
        div_spinner.html('<i class="fa fa-refresh fa-spin"></i>');
        div_spinner.toggle(true);
        self.loadImageUrl(url, 'ct', args.init_index);
        return $.get("/predict/" + cttype + "-" + suid + ".json").done(function(data, status, jqXHR) {
          var candidate, j, len1, p, x, y, z;
          tbody.html('');
          for (j = 0, len1 = data.length; j < len1; j++) {
            candidate = data[j];
            x = candidate[0][0];
            y = candidate[0][1];
            z = candidate[0][2];
            p = candidate[1][0].toFixed(2);
            tbody.append($.trim("<tr>\n  <td>" + x + "</td>\n  <td>" + y + "</td>\n  <td><a href='#' class='prediction' data-x='" + x + "' data-y='" + y + "' data-z='" + z + "' data-p='" + p + "'>" + z + "</a></td>\n  <td>" + p + "</td>\n</tr>"));
          }
          div_spinner.toggle(false);
          return $("a.prediction").click(function(e) {
            e.preventDefault();
            if (self.ui_index) {
              x = $(e.target).data('x');
              y = $(e.target).data('y');
              z = $(e.target).data('z');
              self.ui_index.val(z).change();
              return self.setCrosshairs(x, y);
            }
          });
        }).fail(function(data, status, jqXHR) {
          return div_spinner.html('<i class="fa fa-refresh fa-exclamation-circle"></i>');
        });
      });
      $("#suid").change();
      this.registerEventHandlers();
    }

    SliceViewer.prototype.loadImageUrl = function(url, name, init_index) {
      var self, storeImageData;
      self = this;
      storeImageData = (function(_this) {
        return function(imageObj, name, canvas, ntiles, init_index) {
          return new SliceViewerLayer({
            name: name,
            canvas: canvas,
            image: imageObj,
            width: _this.width,
            height: _this.height,
            ntiles: ntiles,
            init_index: init_index != null ? init_index : 0
          });
          return {
            parent: _this
          };
        };
      })(this);
      if (!this.image) {
        this.image = new Image;
        this.image.onload = function() {
          var img_elem;
          img_elem = this;
          return $.getJSON(this.src + "?json=1").done(function(data, status, jqXHR) {
            var canvas, layer, ntiles;
            ntiles = data.shape[0];
            canvas = self.name2canvas[name];
            layer = self.name2layer[name] = storeImageData(img_elem, name, canvas, ntiles, init_index);
            if (self.ui_index && name === 'ct') {
              self.ui_index.val(layer.current_index);
            }
            return self.setCrosshairs(self.crosshair_x, self.crosshair_y);
          }).fail(function(data, status, jqXHR) {
            return console.error(url + "?json=1");
          });
        };
      }
      if (url) {
        return this.image.src = url;
      }
    };

    SliceViewer.prototype.registerEventHandlers = function() {
      var next, prev, self;
      self = this;
      next = function() {
        var i, index, layer, len, name, ref;
        if (self.ui_index) {
          index = parseInt(self.ui_index.val()) + 1;
          self.ui_index.val(index).change();
        } else {
          ref = self.name2layer;
          for (name = i = 0, len = ref.length; i < len; name = ++i) {
            layer = ref[name];
            layer.drawNext();
          }
        }
        return self.setCrosshairs(self.crosshair_x, self.crosshair_y);
      };
      prev = function() {
        var index, layer, name, ref;
        if (self.ui_index) {
          index = parseInt(self.ui_index.val()) - 1;
          self.ui_index.val(index).change();
        } else {
          ref = self.name2layer;
          for (name in ref) {
            layer = ref[name];
            layer.drawPrev();
          }
        }
        return self.setCrosshairs(self.crosshair_x, self.crosshair_y);
      };
      if (this.ui_index) {
        this.ui_index.change(function(e) {
          var elem, index, layer, name, ref;
          elem = $(e.target);
          index = parseInt(elem.val());
          ref = self.name2layer;
          for (name in ref) {
            layer = ref[name];
            layer.drawSlice(index);
          }
          return elem.val(self.name2layer['ct'].current_index);
        });
      }
      if (this.ui_prev) {
        $(this.ui_prev.click(function(e) {
          return prev();
        }));
      }
      if (this.ui_next) {
        $(this.ui_next.click(function(e) {
          return next();
        }));
      }
      this.container.bind("mousewheel", function(e) {
        e.prevent;
        if (e.originalEvent.wheelDelta / 120 > 0) {
          return next();
        } else {
          return prev();
        }
      });
      this.crosshair_canvas.click((function(_this) {
        return function(e) {
          e.preventDefault();
          e.stopPropagation();
          self.crosshair_x = e.pageX - e.target.offsetLeft;
          self.crosshair_y = e.pageY - e.target.offsetTop;
          console.log("clicked at " + e.pageX + ", " + e.pageY + " -> " + self.crosshair_x + ", ," + self.crosshair_y);
          return $('canvas').trigger('crosshairsClick', [self.crosshair_x, self.crosshair_y]);
        };
      })(this));
      this.crosshair_canvas.on('crosshairsClick', (function(_this) {
        return function(e, x, y) {
          return _this.setCrosshairs(x, y);
        };
      })(this));
      return null;
    };

    SliceViewer.prototype.renderTo = function(elem) {
      var canvas, name, ref;
            if (elem != null) {
        elem;
      } else {
        console.error("cannot render to null elem");
      };
      elem = $(elem);
      ref = this.name2canvas;
      for (name in ref) {
        canvas = ref[name];
        elem.append(canvas);
      }
      return elem.append(this.crosshair_canvas);
    };

    SliceViewer.prototype.setCrosshairs = function(x, y) {
      var canvas, ctx, i, j, layer, name, profile, ref, results, results1, results2;
      this.crosshair_x = x;
      this.crosshair_y = y;
      ctx = this.crosshair_canvas[0].getContext('2d');
      canvas = ctx.canvas;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
      ref = this.name2layer;
      results = [];
      for (name in ref) {
        layer = ref[name];
        if (this.ui_x_profile) {
          profile = layer.tile.getXcrossSection(layer.current_index, y);
          Plotly.newPlot(this.ui_x_profile.get(0), [
            {
              x: (function() {
                results1 = [];
                for (i = 0; i < 512; i++){ results1.push(i); }
                return results1;
              }).apply(this),
              y: pixel2HU(profile)
            }
          ], {
            autosize: false,
            width: 552,
            height: 240,
            margin: {
              t: 20,
              b: 20,
              l: 34,
              r: 0,
              pad: 0
            },
            yaxis: {
              range: [-1000, 2000]
            }
          });
        }
        if (this.ui_y_profile) {
          profile = layer.tile.getYcrossSection(layer.current_index, x);
          results.push(Plotly.newPlot(this.ui_y_profile.get(0), [
            {
              x: (function() {
                results2 = [];
                for (j = 0; j < 512; j++){ results2.push(j); }
                return results2;
              }).apply(this),
              y: pixel2HU(profile)
            }
          ], {
            autosize: false,
            width: 552,
            height: 250,
            margin: {
              t: 20,
              b: 20,
              l: 35,
              r: 0,
              pad: 0
            },
            yaxis: {
              range: [-1000, 2000]
            }
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return SliceViewer;

  })();

  SliceViewerLayer = (function() {
    function SliceViewerLayer(args) {
      var ref;
      this.name = args.name;
      this.canvas = (ref = args.canvas) != null ? ref : $(document.createElement('canvas'));
      this.canvas = this.canvas.get(0);
      this.canvas.width = args.width;
      this.canvas.height = args.height;
      this.parent = args._parent;
      this.tile = new TileImages(args.image, 512, 512, args.ntiles);
      this.drawSlice(args.init_index);
    }

    SliceViewerLayer.prototype.drawSlice = function(index) {
      var ctx2d;
      if (index == null) {
        index = this.current_index;
      }
      this.current_index = Math.max(index, 0);
      this.current_index = Math.min(this.current_index, this.tile.tile_count - 1);
      ctx2d = this.canvas.getContext('2d');
      return this.tile.drawTileTo(ctx2d, this.current_index);
    };

    SliceViewerLayer.prototype.drawPrev = function() {
      return this.drawSlice(this.current_index - 1);
    };

    SliceViewerLayer.prototype.drawNext = function() {
      return this.drawSlice(this.current_index + 1);
    };

    return SliceViewerLayer;

  })();

  getImage = function(url, idx) {
    return new Promise(function(resolve, reject) {
      var img;
      img = new Image;
      img.onload = function() {
        return resolve({
          url: url,
          idx: idx,
          obj: this
        });
      };
      img.onerror = function() {
        return reject({
          url: url,
          idx: idx,
          obj: this
        });
      };
      return img.src = url;
    });
  };

  ImageSquence = (function() {
    function ImageSquence(url_list, parent) {
      var i, image_obj_list, index, len, promise, self, url;
      this.length = url_list.length;
      this.image_data_list = [];
      image_obj_list = [];
      self = this;
      for (index = i = 0, len = url_list.length; i < len; index = ++i) {
        url = url_list[index];
        promise = getImage(url, index);
        promise.then((function(_this) {
          return function(resolve) {
            var canvas, ctx2d, img, imgdata;
            img = resolve.obj;
            canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx2d = canvas.getContext('2d');
            ctx2d.clearRect(0, 0, canvas.width, canvas.height);
            ctx2d.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
            imgdata = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
            console.log("loaded " + resolve.idx + ": " + resolve.url);
            return self.image_data_list[resolve.idx] = imgdata;
          };
        })(this));
      }
    }

    ImageSquence.prototype.drawTileTo = function(ctx2d, index) {
      var image_data;
      ctx2d.clearRect(0, 0, ctx2d.canvas.width, ctx2d.canvas.height);
      image_data = this.image_data_list[index];
            if (image_data != null) {
        image_data;
      } else {
        console.error("index=" + index + " has no data");
      };
      return ctx2d.putImageData(image_data, 0, 0);
    };

    ImageSquence.prototype.getXcrossSection = function(index, y, x_array) {
      var i, image_data, j, len, profile, ref, ref1, results, x;
      image_data = this.image_data_list[index];
            if (image_data != null) {
        image_data;
      } else {
        console.error("index=" + index + " has no data");
      };
      profile = [];
      ref1 = x_array != null ? x_array : (function() {
        results = [];
        for (var j = 0, ref = image_data.width; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      for (i = 0, len = ref1.length; i < len; i++) {
        x = ref1[i];
        index = this.getDataIndex(image_data, x, y);
        profile.push(image_data.data[index]);
      }
      return profile;
    };

    ImageSquence.prototype.getYcrossSection = function(index, x, y_array) {
      var i, image_data, j, len, profile, ref, ref1, results, y;
      image_data = this.image_data_list[index];
            if (image_data != null) {
        image_data;
      } else {
        console.error("index=" + index + " has no data");
      };
      profile = [];
      ref1 = y_array != null ? y_array : (function() {
        results = [];
        for (var j = 0, ref = image_data.height; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      for (i = 0, len = ref1.length; i < len; i++) {
        y = ref1[i];
        index = this.getDataIndex(image_data, x, y);
        profile.push(image_data.data[index]);
      }
      return profile;
    };

    return ImageSquence;

  })();

  TileImages = (function() {
    function TileImages(image, tile_width, tile_height, tile_count) {
      var canvas, ctx2d, i, imgdata, index, ref, ref1, ref2, x, y;
      this.src_image = image;
      this.img_width = image.width;
      this.img_height = image.height;
      this.tile_width = tile_width;
      this.tile_height = tile_height;
      this.tile_count = tile_count;
      this.row_count = this.img_height / tile_height;
      this.col_count = this.img_width / tile_width;
      this.image_data_list = [];
      canvas = document.createElement('canvas');
      ref = [this.tile_width, this.tile_height], canvas.width = ref[0], canvas.height = ref[1];
      ctx2d = canvas.getContext('2d');
      for (index = i = 0, ref1 = tile_count; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
        ref2 = this.getOffsetFor(index), x = ref2[0], y = ref2[1];
        ctx2d.clearRect(0, 0, canvas.width, canvas.height);
        ctx2d.drawImage(this.src_image, x, y, this.tile_width, this.tile_height, 0, 0, canvas.width, canvas.height);
        imgdata = ctx2d.getImageData(0, 0, canvas.width, canvas.height);
        this.image_data_list.push(imgdata);
      }
    }

    TileImages.prototype.getOffsetFor = function(tile_number) {
      var col, x, y;
      if (tile_number >= this.tile_count) {
        return [null, null];
      }
      tile_number = parseInt(tile_number);
      col = parseInt(tile_number / this.row_count);
      x = col * this.tile_width;
      y = (tile_number % this.row_count) * this.tile_height;
      return [x, y];
    };

    TileImages.prototype.drawTileTo = function(ctx2d, index) {
      var image_data;
      ctx2d.clearRect(0, 0, ctx2d.canvas.width, ctx2d.canvas.height);
      image_data = this.image_data_list[index];
            if (image_data != null) {
        image_data;
      } else {
        console.error("index=" + index + " has no data");
      };
      return ctx2d.putImageData(image_data, 0, 0);
    };

    TileImages.prototype.getDataIndex = function(image_data, x, y) {
      var idx;
      idx = 4 * (image_data.height * y + x);
      if (idx >= image_data.data.length) {
        return null;
      }
      return idx;
    };

    TileImages.prototype.getXcrossSection = function(index, y, x_array) {
      var i, image_data, j, len, profile, ref, ref1, results, x;
      image_data = this.image_data_list[index];
            if (image_data != null) {
        image_data;
      } else {
        console.error("index=" + index + " has no data");
      };
      profile = [];
      ref1 = x_array != null ? x_array : (function() {
        results = [];
        for (var j = 0, ref = image_data.width; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      for (i = 0, len = ref1.length; i < len; i++) {
        x = ref1[i];
        index = this.getDataIndex(image_data, x, y);
        profile.push(image_data.data[index]);
      }
      return profile;
    };

    TileImages.prototype.getYcrossSection = function(index, x, y_array) {
      var i, image_data, j, len, profile, ref, ref1, results, y;
      image_data = this.image_data_list[index];
            if (image_data != null) {
        image_data;
      } else {
        console.error("index=" + index + " has no data");
      };
      profile = [];
      ref1 = y_array != null ? y_array : (function() {
        results = [];
        for (var j = 0, ref = image_data.height; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      for (i = 0, len = ref1.length; i < len; i++) {
        y = ref1[i];
        index = this.getDataIndex(image_data, x, y);
        profile.push(image_data.data[index]);
      }
      return profile;
    };

    return TileImages;

  })();

  pixel2HU = function(array, vmin, vmax) {
    var i, ind, len, profile, x;
    if (vmin == null) {
      vmin = -1000;
    }
    if (vmax == null) {
      vmax = 2000;
    }
    profile = [];
    for (ind = i = 0, len = array.length; i < len; ind = ++i) {
      x = array[ind];
      profile.push((vmax - vmin) / 255 * x + vmin);
    }
    return profile;
  };

}).call(this);
