###
NOTE: this js file is generated by coffee, do not edit this file
###

exportObj = exports ? this

class exportObj.SliceViewer
	# Create a simple slice viewer.
	#
	# A sliceviewer contains many layers
	constructor: (args) ->
		#@slices_url = args.slices_url
		@suid2urls = args.suid2urls
		@container  = args.container

		@width  = parseInt(args.width ? 512)
		@height = parseInt(args.height ? 512)

		# UI elements
		@ui_prev = args?.ui_prev or null
		@ui_next = args?.ui_next or null
		@ui_index = args?.ui_index or null
		@ui_x_profile = args?.ui_x_profile or null
		@ui_y_profile = args?.ui_y_profile or null

		# canvas layers
		@name2canvas ={}
		@name2layer  = {}
		for name, zindex in ['ct']
			canvas = @name2canvas[name] = $ document .createElement 'canvas'
			canvas[0] .width = @width
			canvas[0] .height = @height
			canvas .css 'z-index', zindex
			canvas .css 'position', 'absolute'
			#canvas .css 'margin-left', 'auto'
			#canvas .css 'margin-right', 'auto'

		# crosshair canvas
		@crosshair_canvas = $ document .createElement 'canvas'
		@crosshair_canvas[0] .width = @width
		@crosshair_canvas[0] .height = @height
		@crosshair_canvas .css 'z-index', 9999
		@crosshair_canvas .css 'position', 'absolute'
		#@crosshair_canvas .css 'margin-left', 'auto'
		#@crosshair_canvas .css 'margin-right', 'auto'
		@crosshair_x = args.crosshair_init_x ? @width /2
		@crosshair_y = args.crosshair_init_y ? @height/2

		# call before loading image so that all the elements are added to DOM
		@renderTo @container

		self = @
		$("#suid").change (e) ->
			#suid = $(e.target) .val()
			#url_list = self.suid2urls[suid]
			#self.loadImageUrls url_list, 'ct', args.init_index
			url = $(e.target) .val()
			opt = $(e.target) .find 'option:selected'
			suid   = opt .data 'suid'
			cttype = opt .data 'type'
			tbody = $("#prediction tbody")
			tbody .html ''
			div_spinner = $("#prediction-spinner")
			div_spinner .html '<i class="fa fa-refresh fa-spin"></i>'
			div_spinner .toggle true
			self.loadImageUrl url, 'ct', args.init_index
			$.get "/predict/#{cttype}-#{suid}.json"
				.done (data, status, jqXHR) ->
					tbody .html ''
					for candidate in data
						x = candidate[0][0]
						y = candidate[0][1]
						z = candidate[0][2]
						p = candidate[1][0].toFixed(2)
						tbody .append $.trim """
						<tr>
						  <td>#{x}</td>
						  <td>#{y}</td>
						  <td><a href='#' class='prediction' data-x='#{x}' data-y='#{y}' data-z='#{z}' data-p='#{p}'>#{z}</a></td>
						  <td>#{p}</td>
						</tr>
						"""
					div_spinner .toggle false
					$("a.prediction") .click (e) ->
						e.preventDefault()
						if self.ui_index
							x = $(e.target) .data('x')
							y = $(e.target) .data('y')
							z = $(e.target) .data('z')
							self.ui_index
								.val z
								.change()
							self.setCrosshairs x, y
				.fail (data, status, jqXHR) ->
					div_spinner .html '<i class="fa fa-refresh fa-exclamation-circle"></i>'
		$("#suid") .change()

		do @registerEventHandlers

	#loadImageUrls : (urls, name, init_index) ->
	#	canvas = @name2canvas[name]
	#	layer = @name2layer[name] = new SliceViewerLayer
	#		image_url_list : urls,
	#		parent : @

	loadImageUrl : (url, name, init_index) ->
		self = @
		storeImageData = (imageObj, name, canvas, ntiles, init_index) =>
			return new SliceViewerLayer \
				name    : name,
				canvas  : canvas,
				image   : imageObj,
				width   : @width,
				height  : @height,
				ntiles  : ntiles,
				init_index : init_index ? 0
				parent  : @

		if not @image
			@image = new Image
			@image .onload = ->
				img_elem = this
				$.getJSON "#{this.src}?json=1"
				.done (data, status, jqXHR) ->
					ntiles = data.shape[0]
					canvas = self .name2canvas[name]
					layer = self.name2layer[name] = storeImageData img_elem, name, canvas, ntiles, init_index
					if self.ui_index and name == 'ct'
						self.ui_index .val (layer.current_index)
					self.setCrosshairs self.crosshair_x, self.crosshair_y
				.fail  (data, status, jqXHR) ->
					console.error "#{url}?json=1"
		if url
			@image.src = url # load image

	registerEventHandlers : () ->
		self = this
		next = ->
			if self.ui_index
				index = parseInt(self.ui_index .val()) + 1
				self.ui_index .val(index) .change()
			else
				for layer, name in self.name2layer
					do layer .drawNext
			self.setCrosshairs self.crosshair_x, self.crosshair_y
		prev = ->
			if self.ui_index
				index = parseInt(self.ui_index .val()) - 1
				self.ui_index .val(index) .change()
			else
				for name, layer of self.name2layer
					do layer .drawPrev
			self.setCrosshairs self.crosshair_x, self.crosshair_y
		if @ui_index
			@ui_index .change (e) ->
				elem = $ e.target
				index = parseInt elem .val()
				for name, layer of self.name2layer
					layer .drawSlice index
				elem .val (self.name2layer['ct'].current_index)
		if @ui_prev
			$ @ui_prev .click (e) ->
				do prev
		if @ui_next
			$ @ui_next .click (e) ->
				do next
		@container .bind "mousewheel", (e) ->
			e.prevent
			if e.originalEvent.wheelDelta / 120 > 0
				do next
			else
				do prev
		@crosshair_canvas .click (e) =>
			e.preventDefault()
			e.stopPropagation()
			self.crosshair_x = e.pageX - e.target.offsetLeft
			self.crosshair_y = e.pageY - e.target.offsetTop
			console.log("clicked at #{e.pageX}, #{e.pageY} -> #{self.crosshair_x}, ,#{self.crosshair_y}")
			$('canvas') .trigger 'crosshairsClick', [self.crosshair_x, self.crosshair_y]
		@crosshair_canvas .on 'crosshairsClick', (e, x, y) =>
			@setCrosshairs x, y
		null

	renderTo : (elem) ->
		# Append canvas to <elem>
		elem ? console .error "cannot render to null elem"
		elem = $ elem
		for name, canvas of @name2canvas
			elem .append canvas
		elem .append @crosshair_canvas

	setCrosshairs : (x, y) ->
		@crosshair_x = x
		@crosshair_y = y
		ctx = @crosshair_canvas[0] .getContext '2d'
		canvas = ctx.canvas
		ctx .clearRect 0, 0, canvas.width, canvas.height
		ctx .strokeStyle = 'red'
		ctx .beginPath()
		ctx .moveTo x, 0
		ctx .lineTo x, canvas.height
		ctx .stroke()
		ctx .beginPath()
		ctx .moveTo 0, y
		ctx .lineTo canvas.width, y
		ctx .stroke()

		for name, layer of @name2layer
			if @ui_x_profile
				profile = layer .tile .getXcrossSection layer.current_index, y
				Plotly .newPlot @ui_x_profile.get(0),
					[
						x : [0...512]
						y : pixel2HU profile
					],
						autosize : false
						width : 552
						height: 240
						margin :
							t : 20
							b : 20
							l : 34
							r : 0
							pad : 0
						yaxis :
							range : [-1000, 2000]
			if @ui_y_profile
				profile = layer .tile .getYcrossSection layer.current_index, x
				Plotly .newPlot @ui_y_profile.get(0),
					[
						x : [0...512]
						y : pixel2HU profile
					],
						autosize : false
						width : 552
						height: 250
						margin :
							t : 20
							b : 20
							l : 35
							r : 0
							pad : 0
						yaxis :
							range : [-1000, 2000]

class SliceViewerLayer
	constructor : (args) ->
		# @name
		# @canvas
		# @tile
		# @init_index
		#@image_seq = new ImageSquence args.image_url_list

		@name   = args.name
		@canvas = args.canvas ? $ document .createElement 'canvas'
		@canvas = @canvas.get(0) # DOM
		@canvas.width  = args.width
		@canvas.height = args.height
		@parent = args._parent

		@tile = new TileImages args.image,
			512, 512, args.ntiles

		@drawSlice args.init_index

	drawSlice : (index) ->
		index ?= @current_index
		@current_index = Math.max(index, 0)
		@current_index = Math.min(@current_index, @tile.tile_count-1)
		#console .log "Drawing index #{@current_index}"
		ctx2d = @canvas .getContext '2d'
		@tile .drawTileTo ctx2d, @current_index
	drawPrev : () ->
		@drawSlice @current_index-1
	drawNext : () ->
		@drawSlice @current_index+1

#imageDataFrom = (image) ->
#	'''Return Pixel data of <image>'''
#	canvas = document .createElement 'canvas'
#	[canvas.width, canvas.height] = [image.width, image.height]
#	ctx = canvas .getContext '2d'
#	ctx .drawImage image, 0, 0, image.width, image.height
#	$('.container') .append(canvas)
#	ctx .getImageData 0, 0, image.width, image.height

getImage = (url, idx) ->
	return new Promise (resolve, reject) ->
		img = new Image
		img .onload = () ->
			resolve (
				url : url,
				idx : idx
				obj : this,
			)
		img .onerror = () ->
			reject (
				url : url,
				idx : idx,
				obj : this
			)
		img .src = url

class ImageSquence
	constructor : ( url_list, # a list of image URL, should all be the same dimensions
		parent
	) ->
		@length = url_list.length
		@image_data_list = []
		image_obj_list = []

		self = @

		for url, index in url_list
			promise = getImage(url, index)
			promise .then (resolve) =>
				img = resolve .obj
				canvas = document .createElement 'canvas'
				canvas.width  = img.width
				canvas.height = img.height
				ctx2d = canvas .getContext '2d'
				ctx2d .clearRect 0, 0, canvas.width, canvas.height
				ctx2d .drawImage img, 0, 0, img.width, img.height,
					0, 0, canvas.width, canvas.height
				imgdata = ctx2d .getImageData 0, 0, canvas.width, canvas.height
				console.log("loaded #{resolve.idx}: #{resolve.url}")
				self.image_data_list[resolve.idx] = imgdata

	drawTileTo : (ctx2d, index) ->
		ctx2d .clearRect 0, 0, ctx2d.canvas.width, ctx2d.canvas.height
		image_data = @image_data_list[index]
		image_data ? console.error "index=#{index} has no data"
		ctx2d .putImageData image_data, 0, 0

	getXcrossSection : (index, y, x_array) ->
		image_data = @image_data_list[index]
		image_data ? console.error "index=#{index} has no data"
		profile = []
		for x in x_array ? [0...image_data.width]
			index = @getDataIndex image_data, x, y
			profile .push image_data.data[index]
		profile

	getYcrossSection : (index, x, y_array) ->
		image_data = @image_data_list[index]
		image_data ? console.error "index=#{index} has no data"
		profile = []
		for y in y_array ? [0...image_data.height]
			index = @getDataIndex image_data, x, y
			profile .push image_data.data[index]
		profile

class TileImages
	# Assuming the following tile ordering:
	# | 0   | r    | 2r   |  ......  | (c-1)r   |
	# | 1   | r+1  | 2r+1 |  ......  | (c-1)r+1 |
	# | ... | .... | .... |  ......  | ..       |
	# | ... | .... | .... |  ......  | n        |
	# | ... | .... | .... |  ......  | undef    |
	# | r-1 | 2r-1 | .... | (c-1)r-1 | undef    |
	# each tile is wxh pixels
	# total image pixel is WxH, where W=w*c and H=h*c
	constructor : ( image,
		tile_width,  # must divides imgdata.width
		tile_height, # must divides imgdata.height
		tile_count,  # between (W/w-1)*(H/h) < n <= (W/w)*(H/h)
	) ->
		@src_image   = image
		@img_width   = image.width  # W
		@img_height  = image.height # H
		@tile_width  = tile_width   # w
		@tile_height = tile_height  # h
		@tile_count  = tile_count   # n
		@row_count   = @img_height / tile_height # r
		@col_count   = @img_width  / tile_width  # c

		# Generate tile image data list.  We don't want to be directly
		# manipulating the tiled image because it is generally very large.
		# (canvas seems to break when one of its dimension over certain size.
		# Also, in the future, we might want to perform operation on image
		# data, such as optional color mapping
		@image_data_list = []
		canvas = document .createElement 'canvas'
		[canvas.width, canvas.height] = [@tile_width, @tile_height]
		ctx2d = canvas .getContext '2d'
		for index in [0...tile_count]
			[x, y] = @getOffsetFor index
			ctx2d .clearRect 0, 0, canvas.width, canvas.height
			ctx2d .drawImage @src_image, x, y, @tile_width, @tile_height,
				0, 0, canvas.width, canvas.height
			imgdata = ctx2d .getImageData 0, 0, canvas.width, canvas.height
			@image_data_list .push imgdata
	
	getOffsetFor : (tile_number) ->
		if tile_number >= @tile_count
			return [null, null]
		tile_number = parseInt tile_number
		col = parseInt tile_number / @row_count
		x = col * @tile_width
		y = ( tile_number % @row_count ) * @tile_height
		[x, y]

	drawTileTo : (ctx2d, index) ->
		ctx2d.clearRect 0, 0, ctx2d.canvas.width, ctx2d.canvas.height
		image_data = @image_data_list[index]
		image_data ? console.error "index=#{index} has no data"
		ctx2d .putImageData image_data, 0, 0
	
	getDataIndex : (image_data, x, y) ->
		idx = 4 * (image_data.height * y + x)
		if idx >= image_data.data.length
			return null
		return idx

	getXcrossSection : (index, y, x_array) ->
		image_data = @image_data_list[index]
		image_data ? console.error "index=#{index} has no data"
		profile = []
		for x in x_array ? [0...image_data.width]
			index = @getDataIndex image_data, x, y
			profile .push image_data.data[index]
		profile

	getYcrossSection : (index, x, y_array) ->
		image_data = @image_data_list[index]
		image_data ? console.error "index=#{index} has no data"
		profile = []
		for y in y_array ? [0...image_data.height]
			index = @getDataIndex image_data, x, y
			profile .push image_data.data[index]
		profile

pixel2HU = (array, vmin=-1000, vmax=2000) ->
	profile = []
	for x, ind in array
		profile .push (vmax - vmin) / 255  * x + vmin
	return profile

# eof
